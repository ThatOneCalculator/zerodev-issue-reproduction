"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodePermissionData = exports.getPermissionFromABI = void 0;
const viem_1 = require("viem");
const constants_js_1 = require("../constants.js");
const types_js_1 = require("./types.js");
function getPermissionFromABI({ abi, args, functionName, policyAddress }) {
    if (!abi || !functionName) {
        return {
            selector: undefined,
            rules: undefined
        };
    }
    const abiItem = (0, viem_1.getAbiItem)({
        abi,
        args,
        name: functionName
    });
    if (abiItem?.type !== "function") {
        throw Error(`${functionName} not found in abi`);
    }
    const functionSelector = (0, viem_1.toFunctionSelector)(abiItem);
    let paramRules = [];
    if (args && Array.isArray(args)) {
        paramRules = args
            .map((arg, i) => {
            if (!arg)
                return null;
            if (policyAddress === constants_js_1.CALL_POLICY_CONTRACT_V0_0_1) {
                if (arg.condition === types_js_1.ParamCondition.ONE_OF) {
                    throw Error("The ONE_OF condition is only supported from CALL_POLICY_CONTRACT_V0_0_2 onwards. Please use CALL_POLICY_CONTRACT_V0_0_2 or a later version.");
                }
                return {
                    params: (0, viem_1.pad)((0, viem_1.isHex)(arg.value)
                        ? arg.value
                        : (0, viem_1.toHex)(arg.value), { size: 32 }),
                    offset: i * 32,
                    condition: arg.condition
                };
            }
            let params;
            if (arg.condition === types_js_1.ParamCondition.ONE_OF) {
                params = arg.value.map((value) => (0, viem_1.pad)((0, viem_1.isHex)(value)
                    ? value
                    : (0, viem_1.toHex)(value), { size: 32 }));
            }
            else {
                params = [
                    (0, viem_1.pad)((0, viem_1.isHex)(arg.value)
                        ? arg.value
                        : (0, viem_1.toHex)(arg.value), { size: 32 })
                ];
            }
            return {
                params,
                offset: i * 32,
                condition: arg.condition
            };
        })
            .filter((rule) => rule);
    }
    return {
        selector: functionSelector,
        rules: paramRules
    };
}
exports.getPermissionFromABI = getPermissionFromABI;
const encodePermissionData = (permission, policyAddress) => {
    const permissionParam = {
        components: [
            {
                internalType: "enum CallType",
                name: "callType",
                type: "bytes1"
            },
            {
                name: "target",
                type: "address"
            },
            {
                name: "selector",
                type: "bytes4"
            },
            {
                name: "valueLimit",
                type: "uint256"
            },
            {
                components: [
                    {
                        internalType: "enum ParamCondition",
                        name: "condition",
                        type: "uint8"
                    },
                    {
                        name: "offset",
                        type: "uint64"
                    },
                    {
                        name: "params",
                        type: policyAddress === constants_js_1.CALL_POLICY_CONTRACT_V0_0_1
                            ? "bytes32"
                            : "bytes32[]"
                    }
                ],
                name: "rules",
                type: "tuple[]"
            }
        ],
        name: "permission",
        type: "tuple[]"
    };
    const params = [permissionParam];
    const values = [permission];
    return (0, viem_1.encodeAbiParameters)(params, values);
};
exports.encodePermissionData = encodePermissionData;
//# sourceMappingURL=callPolicyUtils.js.map